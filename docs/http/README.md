# HTTP基础知识

## 一、HTTP部分

### 1 HTTP常用的状态码有哪些？

- 状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误。

- 状态码的类别

```
    状态码  |   类别                         |   原因短语
    -      |   -                           |    -
    1XX	   |   Informational（信息性状态码）  |   接受的请求正在处理
    2XX	   |   Success（成功状态码）	      |   请求正常处理完毕
    3XX	   |   Redirection（重定向状态码）	  |   需要进行附加操作以完成请求
    4XX	   |   Client Error（客户端错误状态码）|   服务器无法处理请求
    5XX	   |   Server Error（服务器错误状态码）|   服务器处理请求出错

```

- 常用的状态码如下

```
   [
        100  Continue   继续，初始的请求已经接受，客户端应当继续发送请求的其余部分。

        200  OK         请求已正常处理，正常返回信息
        201  Created    请求成功并且服务器创建了新的资源，Location报头包含指向新创建资源的URL。
        202  Accepted   服务器已接受请求，但处理尚未完成
        204  No Content 请求处理成功，但没有任何资源可以返回给客户端
        206 Partial Content 是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

        301 Moved Permanently  请求的网页已永久更新到新位置，永久性重定向
        302 Found       资源的URI已临时定位到其他位置了，临时性重定向。
        303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。
        304 Not Modified 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 
        307 Temporary Redirect 临时重定向。与302有相同的含义。当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。

        400 Bad Request  服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。
        401 Unauthorized 请求未授权。
        403 Forbidden   服务器拒绝请求。
        404 Not Found   服务器找不到请求的资源。

        500 Internal Server Error  服务器端错误，无法完成请求。
        502 - Bad Gateway   服务器作为网关或代理，从上游服务器收到无效响应。
        503 Service Unavailable  服务器端暂时无法处理请求（可能是过载或维护）。
    ] 
```

### 2 HTTP的几种请求方法和用途

- `GET`方法
  - 向特定的资源发出请求，本质是发送一个请求来取得服务器上的某一资源

- `POST`方法
  - 向`URL`指定的资源提交数据进行处理请求

- `PUT`方法
  - 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）
  - 跟`POST`方法很像，也是想服务器提交数据。但是，它们之间有不同。`PUT`指定了资源在服务器上的位置，而`POST`没有

- `HEAD`方法
  - 只请求页面的首部

- `DELETE`方法
  - 删除服务器上的指定的资源

- `OPTIONS`方法
  - 用来查询针对请求URI指定资源支持的HTTP请求方法。如果请求成功，会有一个`Allow`的头包含类似`“GET,POST”`这样的信息

- `TRACE`方法
  - 客户端可以对请求消息的传输路径进行追踪，用于测试和诊断

- `CONNECT`方法
  - 在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信

### 3 HTTP中Get 和 Post的区别
  
  1. GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连，POST把提交的数据则放置在是HTTP包的包体中。
  
  2. GET请求在URL中传送的参数是有长度限制的(URL的最大长度是2048个字符， 不同的浏览器略有不同）;POST是没有大小限制的。
  
  3. GET请求只能进行url编码，而POST支持多种编码方式
  
  4. GET产生一个TCP数据包；POST产生两个TCP数据包（firefox浏览器除外）。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

  5. GET在浏览器回退时是无害的，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
  
  6. GET产生的URL地址可以被收藏，POST则不可以。
  
  7. GET请求会被浏览器主动cache，而POST不会，除非手动设置。

  8. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

  9. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制，也允许二进制数据。

  10. GET比POST更不安全，因为参数直接暴露在URL上，所以在发送密码或其他敏感信息时绝不要使用GET。
  

### 4. 网络分层是怎么分层的？

  - OSI七层网络模型:

  ```

    1）物理层：通过媒介传输比特，确定机械及电气规范（比特Bit） 

    2）数据链路层：将比特组装成帧和点到点的传递（帧Frame） 

    3）网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 

    4）传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 

    5）会话层：建立、管理和终止会话（会话协议数据单元SPDU） 

    6）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

    7）应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

  ```

  - TCP/IP分层模型

  ```
    应用层：应用层、表示层、会话层 （HTTP、FTP、SMTP、DNS）

    传输层（TCP和UDP）

    网络层（IP）

    网络接口层: 物理层 、数据链路层（以太网）

  ```

  - OSI与TCP/IP的对比：

    ```
    分层结构：OSI参考模型与TCP/IP协议都采用了分层结构，都是基于独立的协议栈的概念。OSI参考模型有7层，而TCP/IP协议只有4层，即TCP/IP协议没有了表示层和会话层，并且把数据链路层和物理层合并为网络接口层。不过，二者的分层之间有一定的对应关系。

    连接服务：OSI的网络层基本与TCP/IP的网络层对应，二者的功能基本相似，但是寻址方式有较大的区别。
    
    OSI的地址空间为不固定的可变长，由选定的地址命名方式决定，最长可达160字节，可以容纳非常大的网络，因而具有较大的成长空间。根据OSI的规定，网络上每个系统至多可以有256个通信地址。TCP/IP网络的地址空间为固定的4字节（在目前常用的IPV4中是这样，在IPV6中将扩展到16字节）。网络上的每个系统至少有一个唯一的地址与之对应。

    ```

### 5 TCP和UDP的区别

  1. TCP/UDP 都属于传输层的协议

  2. TCP(Transmission Control Protocol，传输控制协议）是面向连接的传输层协议，能够准确可靠的把数据传递给对方，当数据有丢包情况会重发，但是必须和对方建立可靠的连接，会浪费网络流量，主要用在对可靠性要求较高的地方。一个TCP连接必须要经过三次“对话”才能建立起来。

  3. UDP(User Data Protocol，用户数据报协议）是面向无连接的传输层协议，意思是只负责传输数据，不与对方建立连接,不能确保对方是否收到数据和数据的正确顺序，数据的正确性由应用层来校验。主要用于高速传输和实时性要求较高的场合如音视频会议，广播。

### 6 TCP建立连接的三次握手过程

- 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK

  1. 客户端首先发送发送SYN包给服务端,并进入SYN_SENT（同步已发送）状态，等待服务器确认;

  2. 服务端收到SYN包后，然后回传一个带有SYN/ACK标志的数据包给客户端以示传达确认信息,此时服务器进入SYN_RECV（同步收到）状态；;

  3. 客户端收到服务端的SYN+ACK包后，向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入ESTABLISHED（已建立连接）状态，客户端和服务端建立连接，完成三次握手。 若在握手过程中,某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。

- 三次握手过程客户端和服务端状态变化：

  1. 第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；

  2. 第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；

  3. 第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。

### 7 为什么三次握手中客户端还要再发送一次确认呢？可以二次握手吗？

  - 主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

  - 如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

  - 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 8 如果已经建立了连接，但是客户端突然出现故障了怎么办？

  - TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

### 9 TCP协议断开连接的四次挥手过程

  1. 第一次挥手：主动关闭方发送一个FIN包，用来关闭主动方到被动关闭方的数据传送，主动关闭方进入FIN_WAIT_1状态，但是此时主动关闭方还可以接受数据;

  2. 第二次挥手：被动关闭方收到FIN包后，发送一个ACK包给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），被动关闭方进入CLOSE_WAIT状态;

  3. 第三次挥手：被动关闭方发送一个FIN包，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了，被动关闭方进入LAST_ACK状态；

  4. 第四次挥手：主动关闭方收到FIN后，发送一个ACK确认报文给被动关闭方，并进入TIME_WAIT状态；被动关闭方收到ACK确认报文后，进入CLOSED状态;主动关闭方需要经过时间等待计时器设置的时间2MSL后，才进入CLOSED状态。

### 10 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

  - 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步握手。

### 11 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

  1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。这个ACK报文段有可能丢失，使得处于LAST-ACK状态的服务器收不到对已发送的FIN+ACK报文段的确认，服务器超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务器都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务器重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务器无法正常进入到CLOSED状态。

  2. 防止 “已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 12 为什么服务器端易受到SYN攻击？

  - 服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。

  - 防范SYN攻击措施：降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。

### 13 从浏览器地址栏中输入 URL 到页面加载显示完成，这个过程中都发生了什么？

**基础版本**

- 浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（`HTML、JS、CSS`、图象等）；
- 浏览器对加载到的资源（`HTML、JS、CSS`等）进行语法解析，建立相应的内部数据结构（如`HTML`的`DOM`）；
- 载入解析到的资源文件，渲染页面，完成。

**详细版**

1. 在浏览器地址栏输入URL
2. 浏览器查看**缓存**，如果请求资源在缓存中并且未过期，跳转到转码步骤
    1. 如果资源未缓存，发起新请求
    2. 如果已缓存，检验是否过期，未过期则直接提供给客户端，否则与服务器进行验证。
    3. 检验是否过期通常有两个HTTP头进行控制`Expires`和`Cache-Control`：
        - HTTP1.0提供Expires，值为一个绝对时间表示缓存过期日期
        - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大过期时间
3. 浏览器**解析URL**获取协议，主机，端口，path
4. 浏览器**组装一个HTTP（GET）请求报文**
5. 浏览器**获取主机ip地址**，过程如下：
    1. 浏览器缓存
    2. 本机缓存
    3. hosts文件
    4. 路由器缓存
    5. ISP DNS缓存
    6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
6. **打开一个socket与目标IP地址，端口建立TCP链接**，三次握手如下：
    1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
    2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
    3. 客户端发送**ACK=Y+1， Seq=Z**
7. TCP链接建立后**发送HTTP请求**
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将**响应报文通过TCP连接发送回浏览器**
12. 浏览器接收HTTP响应，然后根据情况选择**关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下**：
    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，**进行缓存**
15. 对响应进行**解码**（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释
18. **构建DOM树**：
    1. **Tokenizing**：根据HTML规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图片、样式表、js文件，**启动下载**
20. 构建**CSSOM树**：
    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建CSSOM树
21. **根据DOM树和CSSOM树构建渲染树**:
    1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被css隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的CSSOM规则并应用
    3. 发布可视节点的内容和计算样式
22. **js解析如下**：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
    2. HTML解析器遇到**没有async和defer的script时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
    3. 当解析器遇到设置了**async**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素
    4. 当文档完成解析，document.readState变成interactive
    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用document.write()
    6. 浏览器**在Document对象上触发DOMContentLoaded事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState变为complete，window触发load事件
23. **显示页面**（HTML解析过程中会逐步显示页面）

**详细简版**

1. 从浏览器接收`url`到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

2. 开启网络线程到发出一个完整的`HTTP`请求（这一部分涉及到dns查询，`TCP/IP`请求，五层因特网协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

4. 后台和前台的`HTTP`交互（这一部分包括`HTTP`头部、响应码、报文结构、`cookie`等知识，可以提下静态资源的`cookie`优化，以及编码解码，如`gzip`压缩等）

5. 单独拎出来的缓存问题，`HTTP`的缓存（这部分包括http缓存头部，`ETag`，`catch-control`等）

6. 浏览器接收到`HTTP`数据包后的解析流程（解析`html`-词法分析然后解析成`dom`树、解析`css`生成`css`规则树、合并成`render`树，然后`layout`、`painting`渲染、复合图层的合成、`GPU`绘制、外链资源的处理、`loaded`和`DOMContentLoaded`等）

7. `CSS`的可视化格式模型（元素的渲染规则，如包含块，控制框，`BFC`，`IFC`等概念）

8. `JS`引擎解析过程（`JS`的解释阶段，预处理阶段，执行阶段生成执行上下文，`VO`，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全，`hybrid`模式等等内容）


### 14 HTTP和HTTPS的区别？

  - HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。

  1. HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

  2. HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。

  3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

  4. HTTP的连接很简单，是无状态的。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

### 15 HTTPS的工作原理？

  - HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

  1. Client使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接。

  2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

  3. 客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

  4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

  5. Web服务器利用自己的私钥解密出会话密钥。

  6. Web服务器利用会话密钥加密与客户端之间的通信。

### 16 HTTPS的优缺点?

  - 优点：

  1. 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

  2. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

  3. HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

  - 缺点：

  1. HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

  2. HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

  3. SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

  4. SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

  5. HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

### 17 为什么HTTPS安全?

  - 认证用户或服务器，确保数据发送到正确的客户机或服务器

  - 加密数据以防止数据中途被窃取

  - 维护数据的完整性，保证数据传输过程中不被改变

### 18 对Http/2 了解哪些内容？

  - HTTP/2引入了“服务器推送（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。

  - HTTP/2提供更多的加密支持。

  - HTTP/2完全采用二进制协议。

  - HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。

  - 它增加了头部压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。

### 19 HTTP/2 与 HTTP/1.X的区别？

  1. HTTP/2使用的是二进制传送，HTTP/1.X是文本（字符串）传送。

  二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，更加简洁高效

  2. HTTP/2支持多路复用

   因为有流ID，所以通过同一个HTTP请求实现多个HTTP请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个HTTP请求，针对每个域只使用一个多路复用的连接

  3. HTTP/2头部压缩， 压缩头部信息减小开销

   HTTP/2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值

  4. HTTP/2支持服务器推送

  HTTP/2支持在未经客户端许可的情况下，主动向客户端推送内容

### 20 状态码304缓存的原理是什么？

  - 服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。

  - 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件。

  - 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。

### 21 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

- 01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存->系统缓存->路由器缓存->ISP DNS 缓存->根域名服务器)
- 02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）
- 03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com）
- 04.浏览器跟踪重定向地址，请求另一个带 www 的网址
- 05.服务器处理请求（通过路由读取资源）
- 06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 'text/html'）
- 07.浏览器进 DOM 树构建
- 08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）
- 09.浏览器显示完成页面
- 10.浏览器发送异步请求

### 22 HTTP request报文结构是怎样的?
  
  1. 首行是**Request-Line**包括：**请求方法**，**请求URI**，**协议版本**，**CRLF**
  2. 首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以CRLF结束
  3. 请求头和消息实体之间有一个**CRLF分隔**
  4. 根据实际请求需要可能包含一个**消息实体**

### 23 HTTP response报文结构是怎样的?

  1. 首行是状态行包括：**HTTP版本，状态码，状态描述**，后面跟一个CRLF
  2. 首行之后是**若干行响应头**，包括：**通用头部，响应头部，实体头部**
  3. 响应头部和响应实体之间用**一个CRLF空行**分隔
  4. 最后是一个可能的**消息实体**




    
    


