(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{187:function(t,a,e){"use strict";e.r(a);var r=e(0),v=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"javascript总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript总结","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript总结")]),t._v(" "),e("h2",{attrs:{id:"一、javascript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、javascript","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、JavaScript")]),t._v(" "),e("h3",{attrs:{id:"_1-javascript有几种类型的值？-它们的内存图是怎样的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-javascript有几种类型的值？-它们的内存图是怎样的？","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. JavaScript有几种类型的值？ 它们的内存图是怎样的？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("基本数据类型：Undefined(未定义)、Null(空)、Boolean(布尔值)、Number(数字)、String(字符串)、Symbol --栈")])]),t._v(" "),e("li",[e("p",[t._v("引用数据类型：Object(对象)、Array(数组)、Function(函数) -- 堆")])]),t._v(" "),e("li",[e("p",[t._v("两种类型的区别是：存储位置不同")])]),t._v(" "),e("li",[e("p",[t._v("基本数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；")])]),t._v(" "),e("li",[e("p",[t._v("引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；")])]),t._v(" "),e("li",[e("p",[t._v("引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。")])]),t._v(" "),e("li",[e("p",[t._v("当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。")])])]),t._v(" "),e("h3",{attrs:{id:"_2-如何区分javascript数据类型？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何区分javascript数据类型？","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 如何区分JavaScript数据类型？")]),t._v(" "),e("ol",[e("li",[t._v("typeof   返回值有6种(String、Number、Boolean、Null、Undefined、Object)，都为字符串形式,无法区分null，{ }，[ ],返回结果都为Object类型。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  typeof  123　　         //Number\n\n  typeof 'abc'　　        //String\n\n  typeof  true           //Boolean\n\n  typeof  undefined      //Undefined\n\n  typeof  null           //Object \n\n  typeof  { }            //Object\n\n  typeof  [ ]            //Object\n\n  typeof  console.log()  //Function\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("Object.prototype.toString.call(需要检查的对象)   可以区分null，{ }，[ ]的数据类型，可以用来区分基本数据类型，原生引用类型，以及判断原生JSON对象。")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("判断基本类型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Object.prototype.toString.call(null);        //"[object Null]"\nObject.prototype.toString.call(undefined);   //"[object Undefined]"\nObject.prototype.toString.call("abc");       //"[object String]"\nObject.prototype.toString.call(123);         //"[object Number]"\nObject.prototype.toString.call(true);        //"[object Boolean]"\n')])])])]),t._v(" "),e("li",[e("p",[t._v("判断原生引用类型")]),t._v(" "),e("ul",[e("li",[t._v("函数类型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('Function fn(){console.log(“test”);}\nObject.prototype.toString.call(fn);   //"[object Function]"\n')])])]),e("ul",[e("li",[t._v("数组类型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var arr = [1,2,3];\nObject.prototype.toString.call(arr);  //"[object Array]"\n')])])])])]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("instanceof 用来判断某个构造函数的prototype属性所指向的对象是否存在于另外一个要检测对象的原型链上， 简单说就是判断一个引用类型的变量具体是不是某种类型的对象。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  ({}) instanceof Object              // true\n  ([]) instanceof Array               // true\n  (/aa/g) instanceof RegExp           // true\n  (function(){}) instanceof Function  // true\n\n")])])]),e("h3",{attrs:{id:"_3-介绍javascript有哪些内置对象？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-介绍javascript有哪些内置对象？","aria-hidden":"true"}},[t._v("#")]),t._v(" 3. 介绍JavaScript有哪些内置对象？")]),t._v(" "),e("ul",[e("li",[t._v("数据封装类对象：Object、Array、Boolean、Number、String")]),t._v(" "),e("li",[t._v("其他对象：Function、Arguments、Math、Date、RegExp、Error")]),t._v(" "),e("li",[t._v("ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect")])]),t._v(" "),e("h3",{attrs:{id:"_4-javascript的组成？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-javascript的组成？","aria-hidden":"true"}},[t._v("#")]),t._v(" 4. JavaScript的组成？")]),t._v(" "),e("ul",[e("li",[t._v("JavaScript 由以下三部分组成：\n"),e("ul",[e("li",[t._v("ECMAScript（核心）：JavaScript 语言基础")]),t._v(" "),e("li",[t._v("DOM（文档对象模型）：规定了访问HTML和XML的接口")]),t._v(" "),e("li",[t._v("BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法")])])])]),t._v(" "),e("h3",{attrs:{id:"_5-javascript的原型，原型链-有什么特点？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-javascript的原型，原型链-有什么特点？","aria-hidden":"true"}},[t._v("#")]),t._v(" 5. JavaScript的原型，原型链 ? 有什么特点？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("原型：")]),t._v(" "),e("ul",[e("li",[t._v("JavaScript的所有对象中都包含了一个 ["),e("strong",[t._v("proto")]),t._v("] 内部属性，这个属性所对应的就是该对象的原型")]),t._v(" "),e("li",[t._v("JavaScript的函数对象，除了原型 ["),e("strong",[t._v("proto")]),t._v("] 之外，还预置了 prototype 属性")]),t._v(" "),e("li",[t._v("当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 ["),e("strong",[t._v("proto")]),t._v("]。")])])]),t._v(" "),e("li",[e("p",[t._v("原型链：")]),t._v(" "),e("ul",[e("li",[t._v("当一个对象调用的属性/方法自身不存在时，就会去自己 ["),e("strong",[t._v("proto")]),t._v("] 关联的前辈 prototype 对象上去找")]),t._v(" "),e("li",[t._v("如果没找到，就会去该 prototype 原型 ["),e("strong",[t._v("proto")]),t._v("] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”")])])]),t._v(" "),e("li",[e("p",[t._v("原型特点：")]),t._v(" "),e("ul",[e("li",[t._v("JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变")])])])]),t._v(" "),e("h3",{attrs:{id:"_6-什么是闭包？闭包的作用？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-什么是闭包？闭包的作用？","aria-hidden":"true"}},[t._v("#")]),t._v(" 6. 什么是闭包？闭包的作用？")]),t._v(" "),e("blockquote",[e("p",[t._v("牵扯作用域，可以两者联系起来一起谈")])]),t._v(" "),e("h3",{attrs:{id:"_7-javascript的作用域？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-javascript的作用域？","aria-hidden":"true"}},[t._v("#")]),t._v(" 7. JavaScript的作用域？")]),t._v(" "),e("blockquote",[e("p",[t._v("词法作用域，动态作用域")])]),t._v(" "),e("h3",{attrs:{id:"_8-this指向什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-this指向什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 8. this指向什么？")]),t._v(" "),e("blockquote",[e("p",[t._v("不同情况的调用，"),e("code",[t._v("this")]),t._v("指向分别如何。顺带可以提一下 "),e("code",[t._v("es6")]),t._v(" 中箭头函数没有 "),e("code",[t._v("this")]),t._v(", "),e("code",[t._v("arguments")]),t._v(", "),e("code",[t._v("super")]),t._v(" 等，这些只依赖包含箭头函数最接近的函数")])]),t._v(" "),e("h3",{attrs:{id:"_9-call，apply，bind-三者用法和区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-call，apply，bind-三者用法和区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 9. call，apply，bind 三者用法和区别？")]),t._v(" "),e("blockquote",[e("p",[t._v("参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（"),e("code",[t._v("call")]),t._v("，"),e("code",[t._v("apply")]),t._v(" 立即执行，"),e("code",[t._v("bind")]),t._v(" 是"),e("code",[t._v("return")]),t._v(" 出一个 "),e("code",[t._v("this")]),t._v(" “固定”的函数，这也是为什么 "),e("code",[t._v("bind")]),t._v(" 是强绑定的一个原因）")])]),t._v(" "),e("blockquote",[e("p",[t._v("注：“固定”这个词的含义，它指的固定是指只要传进去了 "),e("code",[t._v("context")]),t._v("，则 "),e("code",[t._v("bind")]),t._v(" 中 "),e("code",[t._v("return")]),t._v(" 出来的函数 "),e("code",[t._v("this")]),t._v(" 便一直指向 "),e("code",[t._v("context")]),t._v("，除非 "),e("code",[t._v("context")]),t._v(" 是个变量")])]),t._v(" "),e("h3",{attrs:{id:"_10-变量声明提升？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-变量声明提升？","aria-hidden":"true"}},[t._v("#")]),t._v(" 10. 变量声明提升？")]),t._v(" "),e("blockquote",[e("p",[e("code",[t._v("js")]),t._v(" 代码在运行前都会进行 "),e("code",[t._v("AST")]),t._v(" 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 "),e("code",[t._v("AST")]),t._v(" 解析，这里也可以说是形成词法作用域的主要原因")])]),t._v(" "),e("h3",{attrs:{id:"_11"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.")])])},[],!1,null,null,null);a.default=v.exports}}]);