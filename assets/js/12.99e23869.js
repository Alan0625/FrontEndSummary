(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{194:function(_,v,e){"use strict";e.r(v);var r=e(0),a=Object(r.a)({},function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"node-js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js","aria-hidden":"true"}},[_._v("#")]),_._v(" Node.js")]),_._v(" "),e("h2",{attrs:{id:"一、node简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、node简介","aria-hidden":"true"}},[_._v("#")]),_._v(" 一、Node简介")]),_._v(" "),e("h3",{attrs:{id:"_1-node诞生的历程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-node诞生的历程","aria-hidden":"true"}},[_._v("#")]),_._v(" 1. Node诞生的历程")]),_._v(" "),e("ul",[e("li",[_._v("2009年5月发布最初版本")])]),_._v(" "),e("h3",{attrs:{id:"_2-node的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-node的特点","aria-hidden":"true"}},[_._v("#")]),_._v(" 2. Node的特点")]),_._v(" "),e("ul",[e("li",[_._v("异步I/O")]),_._v(" "),e("li",[_._v("事件与回调函数")]),_._v(" "),e("li",[_._v("单线程(子进程)")]),_._v(" "),e("li",[_._v("跨平台")])]),_._v(" "),e("h3",{attrs:{id:"_3-node的应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-node的应用场景","aria-hidden":"true"}},[_._v("#")]),_._v(" 3. Node的应用场景")]),_._v(" "),e("ul",[e("li",[_._v("I/O密集型")]),_._v(" "),e("li",[_._v("分布式应用")])]),_._v(" "),e("h2",{attrs:{id:"二、模块机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、模块机制","aria-hidden":"true"}},[_._v("#")]),_._v(" 二、模块机制")]),_._v(" "),e("h3",{attrs:{id:"_1-commonjs规范"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-commonjs规范","aria-hidden":"true"}},[_._v("#")]),_._v(" 1. CommonJS规范")]),_._v(" "),e("ul",[e("li",[_._v("模块引用")]),_._v(" "),e("li",[_._v("模块定义")]),_._v(" "),e("li",[_._v("模块标识")]),_._v(" "),e("li",[_._v("require、module、exports")]),_._v(" "),e("li",[_._v("CommonJS构建的模块导出和引入机制使得用户完全不必考虑变量污染。")])]),_._v(" "),e("h3",{attrs:{id:"_2-node的模块实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-node的模块实现","aria-hidden":"true"}},[_._v("#")]),_._v(" 2. Node的模块实现")]),_._v(" "),e("p",[_._v("在Node中引入模块，需要经历如下3个步骤：")]),_._v(" "),e("ul",[e("li",[_._v("路径分析")]),_._v(" "),e("li",[_._v("文件定位")]),_._v(" "),e("li",[_._v("编译执行")])]),_._v(" "),e("p",[_._v("在Node中，模块分为两类，一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。")]),_._v(" "),e("p",[_._v("核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心\n文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。")]),_._v(" "),e("h3",{attrs:{id:"_3-commonjs、amd、cmd、es6等模块化的对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-commonjs、amd、cmd、es6等模块化的对比","aria-hidden":"true"}},[_._v("#")]),_._v(" 3. CommonJS、AMD、CMD、ES6等模块化的对比")]),_._v(" "),e("ul",[e("li",[_._v("CommmonJS用于node端，是同步加载的，用在服务器端")]),_._v(" "),e("li",[_._v("AMD依赖于requirejs,是异步加载的，是提前加载，立即加载")]),_._v(" "),e("li",[_._v("CMD依赖于seajs,是异步加载，延后加载，就近加载，用时加载")]),_._v(" "),e("li",[_._v("ES6是ES2015的简称，一般通过export来暴露模块，import来导入模块")])]),_._v(" "),e("p",[_._v("CommonJS")]),_._v(" "),e("p",[_._v("commonJS运行于服务器端，node.js的模块系统，就是参照CommonJS规范实现的，每个模块都是一个单独的作用域。\n模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。")]),_._v(" "),e("p",[_._v("服务器端一般采用同步加载文件，也就是说需要某个模块，服务器端便停下来，等待它加载再执行。而浏览器端要保证效率，需要采用异步加载，这就需要一个预处理，提前将所需要的模块文件并行加载好。")]),_._v(" "),e("p",[_._v("CommonJS模块化规范：")]),_._v(" "),e("p",[_._v("1.通过module.exports或exports来暴露模块")]),_._v(" "),e("p",[_._v("2.通过require来加载模块")]),_._v(" "),e("p",[_._v("CommonJS的特点")]),_._v(" "),e("p",[_._v("1.同步加载，一般用于node端")]),_._v(" "),e("p",[_._v("2.一次加载，多次使用。对同一个模块而言，只会运行一次，多次使用时会从缓存中获取")]),_._v(" "),e("p",[_._v("3.模块加载的顺序，按照它出现的顺序")]),_._v(" "),e("p",[_._v("4.代码都运行在模块作用域，不会造成全局污染")]),_._v(" "),e("p",[_._v("AMD")]),_._v(" "),e("p",[_._v("AMD是一种异步加载模块的方式，主要用在浏览器环境中。主要依赖于require.js库")]),_._v(" "),e("p",[_._v("AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块")]),_._v(" "),e("p",[_._v("同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行.")]),_._v(" "),e("p",[_._v("requireJS主要解决两个问题")]),_._v(" "),e("p",[_._v("1、多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 \n2、js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长")]),_._v(" "),e("p",[_._v("require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。")]),_._v(" "),e("p",[_._v("AMD模块化规范：")]),_._v(" "),e("p",[_._v("1.通过define()方法定义模块")]),_._v(" "),e("p",[_._v("2.通过require方法加载模块")]),_._v(" "),e("p",[_._v("使用方法")]),_._v(" "),e("p",[_._v("1.先加载require.js(从官网下载最新版本)\n2.创建一个主文件(入口文件)\n3.主文件的写法\n4.在主模块中配置模块加载的一些行为(通过require.config()方法)\n5.定义模块(通过define()方法)")]),_._v(" "),e("p",[_._v("CMD(seajs)")]),_._v(" "),e("p",[_._v("依赖就近，延迟加载")]),_._v(" "),e("p",[_._v("CMD推崇就近依赖，只有在用到某个模块的时候再去require")]),_._v(" "),e("p",[_._v("CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同")]),_._v(" "),e("p",[_._v("1.Sea.js 推崇一个模块一个文件，遵循统一的写法")]),_._v(" "),e("p",[_._v("2.CMD加载完某个模块后没有立即执行而是等到遇到require语句的时再执行。")]),_._v(" "),e("p"),_._v(" "),e("p",[_._v("CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的")]),_._v(" "),e("p"),_._v(" "),e("p",[_._v("AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行")]),_._v(" "),e("p",[_._v("这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因")]),_._v(" "),e("p",[_._v("ES6")]),_._v(" "),e("p",[_._v("模块化规范：")]),_._v(" "),e("p",[_._v("一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。\nexport 命令用于规定模块的对外接口。\nimport 命令用于输入其他模块提供的功能。\nexport default:用来默认暴露模块，导入时不需要使用大括号")]),_._v(" "),e("h3",{attrs:{id:"_4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4","aria-hidden":"true"}},[_._v("#")]),_._v(" 4.")])])},[],!1,null,null,null);v.default=a.exports}}]);